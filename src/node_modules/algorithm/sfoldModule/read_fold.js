

var Model = require('../model/');
var Candidate = Model.DomainObjects.Candidate;
var StructureInfo = Model.DomainObjects.StructureInfo;

function RemoveAllValuesFromArray(arr,val)
{
	var index = arr.indexOf(val);
	while(index != -1)
	{
		arr.splice(index, 1);
		index = arr.indexOf(val);
	}
}




function ParseUtilities(){}


//Parses structurex.out containing GCG connect info of the pairs.
// File is read as [Node3]	[NodeBase]	[NodeBefore]	[NodeAfter]  [NodeConnectedTo]	[NodeIndex]
// NodeConnectedTo is zero if it is free
// Takes in the structure, which it modifies to add the pairs
// from site, it is structureX.out
// From local, 10structure.out
// TODO: change for new one file type
ParseUtilities.ParseStructure = 
function (filePath,Struct)
{
	var data = fs.readFileSync(filePath, 'ascii');

	var splited = data.split('\n');
	//First to lines are header
	//node breakdown [0]=positon,[1]=nucleotide base, [2],[3]=prev,next, [4]=connected-to, [5]=node
	for(var ii = 0; ii < (splited.length - 1); ++ii) //-1 due to empty line at eof
	{
		var node = splited[ii].split(' ');
		RemoveAllValuesFromArray(node,'');
		//Skip non-connection strings
		if(node.length!=6)
			continue;
		var connectsTo = parseInt(node[4])
		if(connectsTo != 0) //If the value is zero, it is not connected to anything
		{
			Struct.AddPair(parseInt(node[0]),connectsTo,node[1]);
			//console.log(node.join(','));
		}
		else
		{
			Struct.AddPair(parseInt(node[0]),-1,node[1])
		}
	}
	reading = false;
}


// Parses the summary of the structures that contains 
// minimum free energy and max free energy, and frequency.
// Returns an array of StructureInfo containing the data
// Generally 10structure_2.out
ParseUtilities.ParseStructuresSummary=
function(file)
{

	var StructureInfos = new Array();
	var data = fs.readFileSync(file, 'ascii');
	var splited = data.split('\n');
	console.log("Data lines:"+splited.length);
	for(var ii = 0; ii < (splited.length - 1); ++ii)//-1 due to empty line at eof
	{
		var struct = splited[ii].split(' ');
		RemoveAllValuesFromArray(struct,'');
		StructureInfos.push(new StructureInfo(parseFloat(struct[1]),parseFloat(struct[2]),parseFloat(struct[3]),parseFloat(struct[4])) );
		console.log(struct.join(','));
	}
	return StructureInfos;
}

//	var newCandidate = new Candidate( sequence , cataliticCoreStart, Id, coreType)

// Summarizes the sFold results into an array of candidates
ParseUtilities.ParseSFoldResults = function (directory)
{

	if(directory == undefined)
		directory = '';
	else
		directory += '\\';
		
	//Pattern is location\\ID\\structures\\10structure.out (and 10structure_2.out)
	//TODO: Find ID
	var file_pattern_begin = directory + 'GUC';
	var file_pattern_end = '\\structures\\';
	fs = require('fs');
	var Candidates = new Array();
	for(var struct_num = 0; struct_num < 10; struct_num ++)
	{
		
		console.log("Parsing " +struct_num +"th candidate ");

		var file_pattern = file_pattern_begin + (struct_num).toString() + file_pattern_end;
		var file = file_pattern + '10structure_2.out';
		
		var Structs = ParseUtilities.ParseStructuresSummary(file);
		for(var ii = 1; ii <= 10; ++ii) //Structure files are 1 based, arrays are zero based.
		{
			//TODO: Fix async op properly
			file = file_pattern + 'structure' +ii+ '.out';
			ParseUtilities.ParseStructure(file,Structs[ii-1]);
		}
		
		
		Candidates.push(Structs);
		
		console.log("\n\nFile " + file_pattern + " parsed\n\n********************************");
	}
	return Candidates;
}
	
exports.ParseUtilities=ParseUtilities;






