

var AlgorithmNamespace = require('algorithm');
var Candidate = AlgorithmNamespace.Model.DomainObjects.Candidate;
var StructureInfo = AlgorithmNamespace.Model.DomainObjects.StructureInfo;

function RemoveAllValuesFromArray(arr,val)
{
	var index = arr.indexOf(val);
	while(index != -1)
	{
		arr.splice(index, 1);
		index = arr.indexOf(val);
	}
}




function ParseUtilities(){}


//Parses structurex.out containing GCG connect info of the pairs.
// File is read as [Node3]	[NodeBase]	[NodeBefore]	[NodeAfter]  [NodeConnectedTo]	[NodeIndex]
// NodeConnectedTo is zero if it is free
// Takes in the structure, which it modifies to add the pairs
// from site, it is structureX.out
// From local, 10structure.out
// TODO: change for new one file type
ParseUtilities.ParseStructure = 
function (filePath,Struct)
{
	var data = fs.readFileSync(filePath, 'ascii');

	var splited = data.split('\n');
	//First to lines are header
	//node breakdown [0]=positon,[1]=nucleotide base, [2],[3]=prev,next, [4]=connected-to, [5]=node
	for(var ii = 0; ii < (splited.length - 1); ++ii) //-1 due to empty line at eof
	{
		var node = splited[ii].split(' ');
		RemoveAllValuesFromArray(node,'');
		//Skip non-connection strings
		if(node.length!=6)
			continue;
		var connectsTo = parseInt(node[4])
		if(connectsTo != 0) //If the value is zero, it is not connected to anything
		{
			Struct.AddPair(parseInt(node[0]),connectsTo,node[1]);
			//console.log(node.join(','));
		}
		else
		{
			Struct.AddPair(parseInt(node[0]),-1,node[1])
		}
	}
	reading = false;
}


// Parses the summary of the structures that contains 
// minimum free energy and max free energy, and frequency.
// Returns an array of StructureInfo containing the data
// Generally 10structure_2.out
ParseUtilities.ParseStructuresSummary=
function(file)
{

	var StructureInfos = new Array();
	var data = fs.readFileSync(file, 'ascii');
	var splited = data.split('\n');
	console.log("Data lines:"+splited.length);
	for(var ii = 0; ii < (splited.length - 1); ++ii)//-1 due to empty line at eof
	{
		var struct = splited[ii].split(' ');
		RemoveAllValuesFromArray(struct,'');
		StructureInfos.push(new StructureInfo(parseFloat(struct[1]),parseFloat(struct[2]),parseFloat(struct[3]),parseFloat(struct[4])) );
		console.log(struct.join(','));
	}
	return StructureInfos;
}

//	var newCandidate = new Candidate( sequence , cataliticCoreStart, Id, coreType)

// Summarizes the sFold results into an array of candidates
ParseUtilities.ParseSFoldResults = function (directory)
{

	if(directory == undefined)
		directory = '';
	else
		directory += '\\';
		
	//Pattern is location\\ID\\structures\\10structure.out (and 10structure_2.out)
	//TODO: Find ID
	var file_pattern_begin = directory + 'GUC';
	var file_pattern_end = '\\structures\\';
	fs = require('fs');
	var Candidates = new Array();
	for(var struct_num = 0; struct_num < 10; struct_num ++)
	{
		
		console.log("Parsing " +struct_num +"th candidate ");

		var file_pattern = file_pattern_begin + (struct_num).toString() + file_pattern_end;
		var file = file_pattern + '10structure_2.out';
		
		var Structs = ParseUtilities.ParseStructuresSummary(file);
		for(var ii = 1; ii <= 10; ++ii) //Structure files are 1 based, arrays are zero based.
		{
			//TODO: Fix async op properly
			file = file_pattern + 'structure' +ii+ '.out';
			ParseUtilities.ParseStructure(file,Structs[ii-1]);
		}
		
		
		Candidates.push(Structs);
		
		console.log("\n\nFile " + file_pattern + " parsed\n\n********************************");
	}
	return Candidates;
}
	
	var Candidates = ParseUtilities.ParseSFoldResults();
	
	
	var readline = require('readline');

	var rl = readline.createInterface({
	  input: process.stdin,
	  output: process.stdout
	});

	var end = false;
Ask();
function Ask()
{
	console.log("*********************************\n\n");
	rl.question("Information for candidate,structure: ", 
	function(answer) 
	{
		var splited = answer.split(',');
		var ans = parseInt(splited[1]);
		var cand = parseInt(splited[0]);
		if(ans == -1 || isNaN(cand))
			end = true;
		
		if(end)
		{
			rl.close();
			console.log('exiting...'); 
		}
		else
		{
			console.log("*********************************\n\n");
			console.log("Candidate " + cand);
			if(!isNaN(ans))
			{
				console.log("Structure " + ans + ':');
				var s = Candidates[cand][ans]
				console.log("Frequency:" + s.Frequency);
				console.log("Connections");
				var cg = 0;
				var au = 0;
				for(var ii = 0; ii < s.ConnectedPairs.length;++ii)
				{
					console.log(s.ConnectedPairs[ii]);
					var t = s.ConnectedPairs[ii].type ;
					if(t == 'C' || t == 'G')
						cg++;
					else
						au++;
				}
				cg = cg/2;
				au = au/2;
				console.log("GC total connections: " + cg);
				console.log("AU total connections: " + au);
				console.log("*********************************\n\n");
			}
			else
			{
				if(cand != -1)
				{
					var ss = Candidates[cand];
					
					for(var ii = 0; ii < ss.length;++ii)
					{
						console.log("Struct "+ ii + " freq: " + ss[ii].Frequency); 
						ss[ii].Evaluate(17,0);//Try normal core type
					}
					console.log("*********************************\n\n");
				}
				else
				{
					console.log("Fitness for all candidates:");
					for(var jj = 0; jj < Candidates.length;++jj)
					{
						console.log("\tCandidate :" + (jj).toString());
						var CandFitness = 0 ;
						console.log("	**********   ");
						var ss = Candidates[jj];
						
						for(var ii = 0; ii < ss.length;++ii)
						{
							console.log("Struct "+ ii + " freq: " + ss[ii].Frequency); 
							ss[ii].Evaluate(17,0);
							CandFitness += ss[ii].Fitness * ss[ii].Frequency;
						}
						
						
						ss.OverallFitness = CandFitness; //Dyn add property
						console.log("	**********   ");
						console.log("\tOverall = " +  CandFitness.toFixed(2));
						console.log("	**********   ");
					}
					console.log("*********************************\n\n");
					console.log("*********************************\n\n");
				}
			}
			setTimeout(Ask,100);
		}
	});
}







