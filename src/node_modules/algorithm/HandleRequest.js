var CandidateGenerationModule =  require( './candidateGenerationModule/');
var FoldModule = require ('./sfoldModule/');
var FoldCandidates = FoldModule.Folding.Fold.FoldCandidates;
var ExecuteFolding = FoldModule.Folding.Fold.ExecuteFolding;
var ParseUtilities = FoldModule.Parsing.ParseUtilities;
var Model = require('./model/');
var MeltingTemp = require('./meltingTemp/');
var Candidate = Model.DomainObjects.Candidate;
var Log = require('log').Log
//var ReportObject = Model.DomainObjects.ReportObject;



function ReportObject(request)
{
    this.Request = request;
	this.FileCount = 0;
}


ReportObject.prototype.ExecuteIfComplete = function (part)
{
    Log("Current execution count " + this.FileCount, "ReportObject.ExecuteIfComplete", 6);
    if(this.FileCount % 10 ==0)
        this.Request.UpdateState("There are " + this.FileCount + ' executions left...');
    if(this.FileCount == 0)
    {
        switch (part)
        {
            case 1:
                this.Request.UpdateState("Completed folding of sequences");
                Log('Completed folding of sequences', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart2(this);
                break;
            case 2:
                this.Request.UpdateState('Completed read operation on folding of sequences');
                Log('Completed read operation on folding of sequences', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart3(this);
                break;
            case 3:
                this.Request.UpdateState('Completed folding targets with constraints');
                Log('Completed folding targets with constraints', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart4(this);
                break;
        }
    }
}
function AddCore(sequence, location,CoreStructure)
{
	var coreStructString = '';
	for(var ii = 0; ii < CoreStructure.length; ++ii)
	{
		coreStructString += CoreStructure[ii].type;
	}
	sequence = sequence.substr(0,location)+coreStructString+sequence.substr(location+1); //Kills non annealing c + adds core
	return sequence;
}

function SaveRequest(request) {

    var str = JSON.stringify(request);
    var fs = require('fs');
    fs.writeFileSync(request.ID + '\\requestState.json', str);
    var cutsiteTypesLength = request.CutsiteTypeCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii) {
        var cutsiteType = request.CutsiteTypeCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteType.length ; ++jj) {
            var cutsite = cutsiteType[jj];
            var fwrite = JSON.stringify(cutsite);
            fs.writeFileSync(request.ID + '\\' + cutsite.ID + '\\results.json', fwrite);
        }
    }
}

function CaculateFoldingFitness(request) {
    var cutsiteTypesLength = request.CutsiteTypeCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii) {
        var cutsiteType = request.CutsiteTypeCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteType.length ; ++jj) {
            var cutsite = cutsiteType[jj];
            for (var kk = 0; kk < cutsite.Candidates.length ; ++kk) {
                var candidate = cutsite.Candidates[kk];
                var folds = candidate.StructuresSFold;
                var totalFitness = 0;
                for (var ll = 0; ll < folds.length; ++ll) {
                    folds[ll].Evaluate(candidate.CataliticCoreStart, candidate.CataliticCoreType);
                    totalFitness += folds[ll].Fitness * folds[ll].Frequency;
                }
                candidate.Fitness_Shape = totalFitness;
            }
        }
    }
}
//Request
// {
//	prefs
//	{
//		tempEnv,
//		naEnv,
//		mgEnv,
//		oligoEnv,
//		cutsites,
//		promoter	
//	}
//  CutsiteTypeCandidateContainer : array
//    {
//        element : array (CutsiteType with Cutsites)
//        {
//            Type : string
//            element : object (Cutsite with candidates)
//            {
//                Candidates: array (Candidates),
//                ID : string
//           }
//        }
//    }
//	
//  e.g. : 
//  <CutsiteTypeCandidateContainer>
//        <element:cutsitetype>
//            <type>GUC</type>
//            <element:cutsite>
//                <ID>
//                    GUC0
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element:cutsite>
//            <element>
//                <ID>
//                    GUC1
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//            <element:cutsite>
//                <ID>
//                    GUC2
//               </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//        </element>
//        <element:cutsitetype>
//            <type>GUA</type>
//            <element:cutsite>
//                <ID>
//                    GUA0
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//            <element:cutsite>
//                <ID>
//                    GUA1
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//            <element:cutsite>
//                <ID>
//                    GUA2
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//        </element>
//  </CutsiteTypeCandidateContainer>
//




function HandleRequestPart1(request)
{
    //Make directory for request
    var fs = require('fs');
    fs.mkdirSync(request.ID)
    request.UpdateState("Request being processed");
    var possibleCutsitesTypes = request.Preferences.cutsites;
    
    var CutsiteTypeCandidateContainer = new Array();
    var reportObj = new ReportObject(request);
	//For each cutsite TYPE
	for(var ii = 0 ; ii < possibleCutsitesTypes.length ; ++ii)
	{
        var cutSites = new Array();
        cutSites.Type = possibleCutsitesTypes[ii];

        request.UpdateState("Generating candidates candidate(s) for cutsite type " + cutSites.Type);
		//Generate ii cutsites and jj candidates         
		var rawCandidatesPerCutsite = CandidateGenerationModule.GenerateCandidates 
			(
				request.TargetSequence,
				possibleCutsitesTypes[ii], 
				{
				    'left_arm_min': request.Preferences.left_arm_min,
				    'right_arm_min': request.Preferences.right_arm_min,
				    'left_arm_max': request.Preferences.left_arm_max,
				    'right_arm_max': request.Preferences.right_arm_max,
				    'promoter': request.Preferences.promoter
				}
			);
		request.UpdateState("Generated " + rawCandidatesPerCutsite.length + " candidate(s) for cutsite type " + cutSites.Type);

	    //Clense candidates of too low Melting temperature
		rawCandidatesPerCutsite = MeltingTemp.CleanseCandidates(rawCandidatesPerCutsite,request.Preferences);


		request.UpdateState("Melting temperature computed. New number of candidates is " + rawCandidatesPerCutsite.length + " after removing unfit candidates for cutsite type " + cutSites.Type);

		for(var jj = 0; jj < rawCandidatesPerCutsite.length; ++jj)
        //For each cutsite
		{
		    var generatedCutsiteId = possibleCutsitesTypes[ii] + jj.toString();
		    request.UpdateState("Asynchrnously queueing the fold of cutsite " + generatedCutsiteId + ' candidates');
        	var candidates = new Array();
            var cutsiteCandidates = rawCandidatesPerCutsite [jj];
            for(var kk = 0; kk < cutsiteCandidates.length; ++kk)
            {
                var rawCandidate = cutsiteCandidates[kk];
                var seqWithCore = AddCore(rawCandidate.seq, rawCandidate.cut , Model.DomainObjects.CATALITIC_CORES[request.coreTypeId]);
                var newCandidate  = 
                new Candidate( 
                    seqWithCore,
                    rawCandidate.cut, 
                    /*Generate candidate ID id*/ kk.toString(), 
                    request.coreTypeId, 
                    request.ID ,
                    /*Create cutsite ID*/generatedCutsiteId,
                    rawCandidate.targetLocation,
                    rawCandidate.MeltingTemperature
                    );
                candidates.push(newCandidate);
            }
            //Save the cutsite location at the cutsite level.
            var locationOnTarget = -1;
            if(candidates.length  != 0)
                locationOnTarget = candidates[0].cutSiteLocation;

            cutSites.push
            (
                {
                    'Candidates' : candidates,
                    'ID': generatedCutsiteId,
                    'Location': locationOnTarget
                }
            );

            FoldCandidates 
            ( 
                { 
                    'ID': generatedCutsiteId,
                    'requestID':request.ID
                }, 
                candidates, 
                reportObj
             ) ; 
        }
        CutsiteTypeCandidateContainer.push(cutSites);
	}
	request.CutsiteTypeCandidateContainer = CutsiteTypeCandidateContainer;
	request.UpdateState("Waiting for foldings ...");
}


function _handleRequestPart2(reportObject) 
{
    var request = reportObject.Request;
    var cutsiteTypes = request.Preferences.cutsites;
    for(var ii = 0; ii < cutsiteTypes.length;++ii)
    {
        var cutsiteTypeContainer = request.CutsiteTypeCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteTypeContainer.length; ++jj)
        {
            var cutsiteContainer = cutsiteTypeContainer[jj];
            var parsedCandidates = ParseUtilities.ParseSFoldResults(request.ID, cutsiteContainer.ID);
            var candidates = cutsiteContainer.Candidates;
            Log("Number of candidates in request: " + candidates.length + ", number of candidates parsed: " + parsedCandidates.length, "HandleRequestPart2 execution", 0);
            if (candidates.length != parsedCandidates.length)
            {
                Log("*** Failed execution! Number of parsed candidates and expected candidates in request:cutsite " + request.ID +':'+ cutsiteContainer.ID + " is different *** ", "ERROR in HandleRequestPart2 execution", 0);
            }
            for (var kk = 0; kk < candidates.length && kk < parsedCandidates.length ; ++kk)
            {
                candidates[kk].StructuresSFold = parsedCandidates[kk];
            }
        }
    }
    reportObject.ExecuteIfComplete(2);
}

function HandleRequestPart2(reportObj)
{
    reportObj.Request.UpdateState('Parsing fold results...');
    Log("Entered part 2 for " + reportObj.Request.ID, "HandleRequestPart2", 3);
    var reportObject = new ReportObject(reportObj.Request);
    setTimeout(function () { _handleRequestPart2(reportObject); }, 4000); //Simulate execute async
}

function _handleRequestPart3(reportObject)
{
    var request = reportObject.Request;
    var seq = request.TargetSequence;
    var constraintsArr = new Array();
    var virtualCandidates = new Array();
    for (var ii = 0; ii < request.CutsiteTypeCandidateContainer.length; ++ii)
    {
        var cutsiteType = request.CutsiteTypeCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteType.length; ++jj)
        {
            var cutsite = cutsiteType[jj];
            virtualCandidates.push
                (
                    {
                        'requestID':request.ID,
                        'cutsiteID': cutsite.ID,
                        'ID':'Target'
                    }
                );
            var constraint = { 'left': cutsite.Location - (request.Preferences.left_arm_max - 1), 'right': (request.Preferences.right_arm_max + request.Preferences.left_arm_max + 2) };
            constraint.left = constraint.left > 0 ? constraint.left : 1;
            constraint.right = ((constraint.right + cutsite.Location - 1) < seq.length) ? constraint.right : (seq.length - cutsite.Location);
            constraintsArr.push(constraint);
        }
    }
    reportObject.FileCount = virtualCandidates.length;
    for (var ii = 0; ii < virtualCandidates.length; ++ii)
    {
        ExecuteFolding(virtualCandidates[ii], constraintsArr[ii], reportObject, true);
    }
}

function HandleRequestPart3(reportObj) {
    var request = reportObj.Request;
    Log("Entered part 3 for " + request.ID, "HandleRequestPart3", 3);
    reportObj.Request.UpdateState('Computing ribozyme shape fitness ... ');
    CaculateFoldingFitness(request);
    reportObj.Request.UpdateState('Saving request execution ... ');
    SaveRequest(request);
    reportObj.Request.UpdateState('Folding whole sequence ... ');
    var reportObject = new ReportObject(reportObj.Request);
    setTimeout(function () { _handleRequestPart3(reportObject); }, 4000); //Simulate execute async
    
}


exports.HandleRequestPart1 = HandleRequestPart1;
exports.HandleRequestPart2 = HandleRequestPart2;