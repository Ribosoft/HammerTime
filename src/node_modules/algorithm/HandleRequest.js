var CandidateGenerationModule =  require( './candidateGenerationModule/');
var FoldModule = require ('./sfoldModule/');
var FoldCandidates = FoldModule.Folding.Fold.FoldCandidates;
var ParseUtilities = FoldModule.Parsing.ParseUtilities;
var Model = require('./model/');
var MeltingTemp = require('./meltingTemp/');
var Candidate = Model.DomainObjects.Candidate;
var Log = require('log').Log
//var ReportObject = Model.DomainObjects.ReportObject;



function ReportObject(request)
{
    this.Request = request;
	this.FileCount = 0;
}


ReportObject.prototype.ExecuteIfComplete = function (part)
{
    Log("Current file count " + this.FileCount, "ReportObject.ExecuteIfComplete", 6); 
    if(this.FileCount == 0)
    {
        switch (part)
        {
            case 1:
                Log('Completed folding of sequences', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart2(this);
                break;
            case 2:
                Log('Completed read operation on folding of sequences', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart3(this);
                break;
        }
    }
}
function AddCore(sequence, location,CoreStructure)
{
	var coreStructString = '';
	for(var ii = 0; ii < CoreStructure.length; ++ii)
	{
		coreStructString += CoreStructure[ii].type;
	}
	sequence = sequence.substr(0,location)+coreStructString+sequence.substr(location+1); //Kills non annealing c + adds core
	return sequence;
}

//Request
// {
//	prefs
//	{
//		tempEnv,
//		naEnv,
//		mgEnv,
//		oligoEnv,
//		cutsites,
//		promoter	
//	}
//  CutsiteTypeCandidateContainer : array
//    {
//        element : array (CutsiteType with Cutsites)
//        {
//            Type : string
//            element : object (Cutsite with candidates)
//            {
//                Candidates: array (Candidates),
//                ID : string
//           }
//        }
//    }
//	
//  e.g. : 
//  <CutsiteTypeCandidateContainer>
//        <element:cutsitetype>
//            <type>GUC</type>
//            <element:cutsite>
//                <ID>
//                    GUC0
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element:cutsite>
//            <element>
//                <ID>
//                    GUC1
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//            <element:cutsite>
//                <ID>
//                    GUC2
//               </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//        </element>
//        <element:cutsitetype>
//            <type>GUA</type>
//            <element:cutsite>
//                <ID>
//                    GUA0
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//            <element:cutsite>
//                <ID>
//                    GUA1
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//            <element:cutsite>
//                <ID>
//                    GUA2
//                </ID>
//                <Candidates>
//                </Candidates>
//            </element>
//        </element>
//  </CutsiteTypeCandidateContainer>
//




function HandleRequestPart1(request)
{
    //Make directory for request
    var fs = require('fs');
    fs.mkdirSync(request.ID)
    
    var possibleCutsitesTypes = request.Preferences.cutsites;
    
    var CutsiteTypeCandidateContainer = new Array();
    var reportObj = new ReportObject(request);
	//For each cutsite TYPE
	for(var ii = 0 ; ii < possibleCutsitesTypes.length ; ++ii)
	{
        var cutSites = new Array();
        cutSites.Type = possibleCutsitesTypes[ii];

		//Generate ii cutsites and jj candidates         
		var rawCandidatesPerCutsite = CandidateGenerationModule.GenerateCandidates 
			(
				request.TargetSequence,
				possibleCutsitesTypes[ii], 
				{
				    'left_arm_min': request.Preferences.left_arm_min,
				    'right_arm_min': request.Preferences.right_arm_min,
				    'left_arm_max': request.Preferences.left_arm_max,
				    'right_arm_max': request.Preferences.right_arm_max,
				    'promoter': request.Preferences.promoter
				}
			);
        
	    //Clense candidates of too low Melting temperature
		rawCandidatesPerCutsite = MeltingTemp.CleanseCandidates(rawCandidatesPerCutsite,request.Preferences);

		for(var jj = 0; jj < rawCandidatesPerCutsite.length; ++jj)
        //For each cutsite
        {
            
        	var candidates = new Array();
            var cutsiteCandidates = rawCandidatesPerCutsite [jj];
            for(var kk = 0; kk < cutsiteCandidates.length; ++kk)
            {
                var rawCandidate = cutsiteCandidates[kk];
                var seqWithCore = AddCore(rawCandidate.seq, rawCandidate.cut , Model.DomainObjects.CATALITIC_CORES[request.coreTypeId]);
                var newCandidate  = 
                new Candidate( 
                    seqWithCore,
                    rawCandidate.cut, 
                    /*Generate candidate ID id*/ kk.toString(), 
                    request.coreTypeId, 
                    request.ID ,
                    /*Create cutsite ID*/possibleCutsitesTypes[ii] + jj.toString(),
                    rawCandidate.targetLocation,
                    rawCandidate.MeltingTemperature
                    );
                candidates.push(newCandidate);
            }
            
            cutSites.push
            (
                {
                    'Candidates' : candidates,
                    'ID' : possibleCutsitesTypes[ii] + jj.toString()
                }
            );

            FoldCandidates 
            ( 
                { 
                    'ID' : possibleCutsitesTypes[ii] + jj.toString(), 
                    'requestID':request.ID
                }, 
                candidates, 
                reportObj
             ) ; 
        }
        CutsiteTypeCandidateContainer.push(cutSites);
	}
	request.CutsiteTypeCandidateContainer = CutsiteTypeCandidateContainer;
	
}


function _handleRequestPart2(reportObject) 
{
    var request = reportObject.Request;
    var cutsiteTypes = request.Preferences.cutsites;
    for(var ii = 0; ii < cutsiteTypes.length;++ii)
    {
        var cutsiteTypeContainer = request.CutsiteTypeCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteTypeContainer.length; ++jj)
        {
            var cutsiteContainer = cutsiteTypeContainer[jj];
            var parsedCandidates = ParseUtilities.ParseSFoldResults(request.ID, cutsiteContainer.ID);
            var candidates = cutsiteContainer.Candidates;
            Log("Number of candidates in request: " + candidates.length + ", number of candidates parsed: " + parsedCandidates.length, "HandleRequestPart2 execution", 0);
            if (candidates.length != parsedCandidates.length)
            {
                Log("*** Failed execution! Number of parsed candidates and expected candidates in request:cutsite " + request.ID +':'+ cutsiteContainer.ID + " is different *** ", "ERROR in HandleRequestPart2 execution", 0);
            }
            for (var kk = 0; kk < candidates.length && kk < parsedCandidates.length ; ++kk)
            {
                candidates[kk].StructuresSFold = parsedCandidates[kk];
            }
        }
    }
    reportObject.ExecuteIfComplete(2);
}

function HandleRequestPart2(reportObj)
{
    Log("Entered part 2 for " + reportObj.Request.ID, "HandleRequestPart2", 3);
    var reportObject = new ReportObject(reportObj.Request);
    _handleRequestPart2(reportObject); //Simulate execute async
}

function SaveRequest(request)
{
   
    var str = JSON.stringify(request);
    var fs = require('fs');
    fs.writeFileSync(request.ID + '\\requestState.json', str);
    var cutsiteTypesLength = request.CutsiteTypeCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii)
    {
        var cutsiteType = request.CutsiteTypeCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteType.length ; ++jj)
        {
            var cutsite = cutsiteType[jj];
            var fwrite = JSON.stringify(cutsite);
            fs.writeFileSync(request.ID + '\\'+ cutsite.ID +'\\results.json', fwrite);
        }
    }
}

function CaculateFoldingFitness(request)
{
    var cutsiteTypesLength = request.CutsiteTypeCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii)
    {
        var cutsiteType = request.CutsiteTypeCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteType.length ; ++jj)
        {
            var cutsite = cutsiteType[jj];
            for (var kk = 0; kk < cutsite.Candidates.length ; ++kk)
            {
                var candidate = cutsite.Candidates[kk];
                var folds = candidate.StructuresSFold;
                var totalFitness = 0;
                for (var ll = 0; ll < folds.length; ++ll)
                {
                    folds[ll].Evaluate(candidate.CataliticCoreStart, candidate.CataliticCoreType);
                    totalFitness += folds[ll].Fitness * folds[ll].Frequency;
                }
                candidate.Fitness_Shape = totalFitness;
            }
        }
    }
}

function HandleRequestPart3(reportObj) {
    var request = reportObj.Request;
    Log("Entered part 2 for " + request.ID, "HandleRequestPart3", 3);
    CaculateFoldingFitness(request);
    SaveRequest(request);
   // Log("Result : " + request.toString(), "HandleRequestPart3", 0);
}


exports.HandleRequestPart1 = HandleRequestPart1;
exports.HandleRequestPart2 = HandleRequestPart2;