var CandidateGenerationModule =  require( './candidateGenerationModule/');
var FoldModule = require ('./sfoldModule/');
var FoldCandidates = FoldModule.Folding.Fold.FoldCandidates;
var ExecuteFolding = FoldModule.Folding.Fold.ExecuteFolding;
var SFold = FoldModule.Folding.Fold.SFold;
var ParseUtilities = FoldModule.Parsing.ParseUtilities;
var Model = require('./model/');
var MeltingTemp = require('./meltingTemp/');
var Candidate = Model.DomainObjects.Candidate;
var CutsiteTypeCutsiteContainer = Model.DomainObjects.CutsiteTypeCutsiteContainer;
var Log = require('log').Log
//var ReportObject = Model.DomainObjects.ReportObject;
var path = require('path');


function ReportObject(request)
{
    this.Request = request;
	this.FileCount = 0;
}


ReportObject.prototype.ExecuteIfComplete = function (part)
{
    Log("Current execution count " + this.FileCount, "ReportObject.ExecuteIfComplete", 6);
    if(this.FileCount % 10 ==0)
        this.Request.UpdateState("There are " + this.FileCount + ' executions left...');
    if(this.FileCount == 0)
    {
        switch (part)
        {
            case 1:
                this.Request.UpdateState("Completed folding of sequences");
                Log('Completed folding of sequences', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart2(this);
                break;
            case 2:
                this.Request.UpdateState('Completed read operation on folding of sequences');
                Log('Completed read operation on folding of sequences', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart3(this);
                break;
            case 3:
                this.Request.UpdateState('Completed folding targets with constraints');
                Log('Completed folding targets with constraints', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart4(this);
                break;
            case 4:
                this.Request.UpdateState('Completed reading targets with constraints');
                Log('Completed reading targets with constraints', 'ReportObject.ExecuteIfComplete', 3);
                SaveRequest(this.Request);
                HandleRequestPart5(this);
                break;
            case 5:
                this.Request.UpdateState('Completed folding target without constraints');
                Log('Completed folding target without constraints', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart6(this);
                break;
            case 6:
                Log('All main folding complete', 'ReportObject.ExecuteIfComplete', 3);
                HandleRequestPart7(this);
                break;
        }
    }
}
function AddCore(sequence, location,CoreStructure)
{
	var coreStructString = '';
	for(var ii = 0; ii < CoreStructure.length; ++ii)
	{
		coreStructString += CoreStructure[ii].type;
	}
	sequence = sequence.substr(0,location)+coreStructString+sequence.substr(location+1); //Kills non annealing c + adds core
	return sequence;
}

function SaveRequest(request) {

    var str = JSON.stringify(request);
    var fs = require('fs');
    fs.writeFileSync(path.join(request.ID, 'requestState.json'), str);
    var cutsiteTypesLength = request.CutsiteTypesCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii) {
        var cutsiteTypeCutsiteContainer = request.CutsiteTypesCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteTypeCutsiteContainer.Cutsites.length ; ++jj) {
            var cutsite = cutsiteTypeCutsiteContainer.Cutsites[jj];
            var fwrite = JSON.stringify(cutsite);
            fs.writeFileSync(path.join(request.ID, cutsite.ID, 'results.json'), fwrite);
        }
    }
}

function CaculateCandidateFoldingFitness(request) {
    var cutsiteTypesLength = request.CutsiteTypesCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii) {
        var cutsiteTypeCutsiteContainer = request.CutsiteTypesCandidateContainer[ii].Cutsites;
        for (var jj = 0; jj < cutsiteTypeCutsiteContainer.length ; ++jj) {
            var cutsite = cutsiteTypeCutsiteContainer[jj];
            for (var kk = 0; kk < cutsite.Candidates.length ; ++kk) {
                var candidate = cutsite.Candidates[kk];
                var folds = candidate.StructuresSFold;
                var totalFitness = 0;
                for (var ll = 0; ll < folds.length; ++ll) {
                    folds[ll].Evaluate(candidate.CataliticCoreStart, candidate.CataliticCoreType, request.Preferences);
                    totalFitness += folds[ll].Fitness * folds[ll].Frequency;
                }
                candidate.Fitness_Shape = totalFitness;
            }
        }
    }
}

function _getContiniousPairsInRegion(structureInfo, start, end)
{
    var result = new Array();
    var pairs = structureInfo.ConnectedPairs;
    for (var ii = start; ii < end && ii < pairs.length; ++ii)
    {
        var continiousSeq = '';
        for (var jj = ii; jj < pairs.length; ++jj)
        {
            if (pairs[jj].right != -1)
                continiousSeq += pairs.type;
            else if (jj + 1 < pairs.length && pairs[jj + 1] == -1)
            {
                if (continiousSeq.length != 0)
                {
                    result.push(continiousSeq);
                    ii = jj;
                    break;
                }
            }
            else if (jj + 1 < pairs.length && pairs[jj + 1] != -1) {
                jj += 1;
            }
            else
            {
                if (continiousSeq.length != 0)
                {
                    result.push(continiousSeq);
                    ii = jj;
                    break;
                }
            }
        }
    }
}

function EvaluateTargetFoldsFitness(structureInfoArray, leftArmLength, rightArmLength, cutSiteLocation, saltConc)
{
    if(saltConc == undefined)
        saltConc = null;
    //in gabs pc this will be out of bounds since the same file is spewed regardless of the candidate...
    var totalFitness = 0;
    for (var ii = 0 ; ii < structureInfoArray.length; ++ii)
    {
        var continiousSeqArr = _getContiniousPairsInRegion(structureInfoArray[ii], cutSiteLocation - leftArmLength, cutSiteLocation + rightArmLength);
        var partialFitness = 0;
        for (var jj = 0; jj < continiousSeqArr.length; ++jj)
        {
            if(saltConc == null)
                partialFitness += MeltingTemp.MeltingTCalc.tm_Basic(continiousSeqArr[jj]);
            else
                partialFitness += MeltingTemp.MeltingTCalc.tm_Salt_Adjusted(continiousSeqArr[jj],saltConc );
        }
    }
}

function EvaluateFitnesses(request)
{
    var NormalSFoldShapes = request.SFoldStructures;
    var cutsiteTypesLength = request.CutsiteTypesCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii)
    {
        var cutsiteTypeCutsiteContainer = request.CutsiteTypesCandidateContainer[ii].Cutsites;
        for (var jj = 0; jj < cutsiteTypeCutsiteContainer.length ; ++jj)
        {
            var cutsite = cutsiteTypeCutsiteContainer[jj];
            var ConstrainedSFoldStructures = cutsite.ConstrainedSFoldStructures;
            for (var kk = 0; kk < cutsite.Candidates.length ; ++kk)
            {
                var candidate = cutsite.Candidates[kk];
                //Check the cutsite region for annealing Temperature
                candidate.Fitness_Target = EvaluateTargetFoldsFitness(NormalSFoldShapes, candidate.LeftArmLength, candidate.RightArmLength, candidate.cutSiteLocation, request.Preferences.naEnv);
                //This might be inverted. In the end, the closer it is to zero the better. It will always have one sign or the other.
                //if it has both, it would mean that it is easier to have a completely open cutsite than a normal cutsite.
                candidate.Fitness_Target_dG = request.AverageLowestFreeEnergy - cutsite.AverageLowestFreeEnergy;
                candidate.Fitness_AnnealingT = candidate.MeltingTemperature; //We could normalize. (this would mean adding 276 to transform to kelvin, then divide by the biggest one). I feel this is more descriptive and less convoluted
            }
        }
    }
}

//Request
// {
//	prefs
//	{
//		tempEnv,
//		naEnv,
//		mgEnv,
//		oligoEnv,
//		cutsites,
//		promoter	
//	}
//  CutsiteTypesCandidateContainer : array
//    {
//        element : array (CutsiteType with Cutsites)
//        {
//            Type : string
//            element : object (Cutsite with candidates)
//            {
//                Candidates: array (Candidates),
//                ID : string
//           }
//        }
//    }
//	

/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* *****************************************************  Part 1 ***************************************************** */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
function HandleRequestPart1(request)
{
    //Make directory for request
    var fs = require('fs');
    fs.mkdirSync(request.ID);
    request.UpdateState("Request being processed");
    var possibleCutsitesTypes = request.Preferences.cutsites;
    
    var CutsiteTypesCandidateContainer = new Array();
    var reportObj = new ReportObject(request);
	//For each cutsite TYPE
	for(var ii = 0 ; ii < possibleCutsitesTypes.length ; ++ii)
	{
	    var cutsiteTypeCutsiteContainer = new CutsiteTypeCutsiteContainer(possibleCutsitesTypes[ii]);
        var cutSites = new Array();
        
        request.UpdateState("Generating candidates candidate(s) for cutsite type " + cutsiteTypeCutsiteContainer.Type);
		//Generate ii cutsites and jj candidates         
		var rawCandidatesPerCutsite = CandidateGenerationModule.GenerateCandidates 
			(
				request.TargetSequence,
				possibleCutsitesTypes[ii], 
				{
				    'left_arm_min': request.Preferences.left_arm_min,
				    'right_arm_min': request.Preferences.right_arm_min,
				    'left_arm_max': request.Preferences.left_arm_max,
				    'right_arm_max': request.Preferences.right_arm_max,
				    'promoter': request.Preferences.promoter
				}
			);
		request.UpdateState("Generated " + rawCandidatesPerCutsite.length + " candidate(s) for cutsite type " + cutsiteTypeCutsiteContainer.Type);

	    //Clense candidates of too low Melting temperature
		rawCandidatesPerCutsite = MeltingTemp.CleanseCandidates(rawCandidatesPerCutsite,request.Preferences);

	    //Add promoter to candidate
		rawCandidatesPerCutsite = CandidateGenerationModule.AppendPromoterToMany(rawCandidatesPerCutsite, request.Preferences.promoter, 3);//The 3 is the amount that the promoter we use allows to be identical (e.g. if the promoter is GUGGC and the candidate is ABDDGU , then we can recycle the DGU, but only GU is equal so only GU)

		request.UpdateState("Melting temperature computed. New number of candidates is " + rawCandidatesPerCutsite.length + " after removing unfit candidates for cutsite type " + cutsiteTypeCutsiteContainer.Type);

		for(var jj = 0; jj < rawCandidatesPerCutsite.length; ++jj)
        //For each cutsite
		{
		    var generatedCutsiteId = possibleCutsitesTypes[ii] + jj.toString();
		    request.UpdateState("Asynchrnously queueing the fold of cutsite " + generatedCutsiteId + ' candidates');
        	var candidates = new Array();
            var cutsiteCandidates = rawCandidatesPerCutsite [jj];
            for(var kk = 0; kk < cutsiteCandidates.length; ++kk)
            {
                var rawCandidate = cutsiteCandidates[kk];
                var seqWithCore = AddCore(rawCandidate.seq, rawCandidate.cut , Model.DomainObjects.CATALITIC_CORES[request.coreTypeId]);
                var newCandidate  = 
                new Candidate( 
                    seqWithCore,
                    rawCandidate.cut, 
                    /*Generate candidate ID id*/ kk.toString(), 
                    request.coreTypeId, 
                    request.ID ,
                    /*Create cutsite ID*/generatedCutsiteId,
                    rawCandidate.targetLocation,
                    rawCandidate.MeltingTemperature,
                    rawCandidate.left,
                    rawCandidate.right
                    );
                candidates.push(newCandidate);
            }
            //Save the cutsite location at the cutsite level.
            var locationOnTarget = -1;
            if(candidates.length  != 0)
                locationOnTarget = candidates[0].cutSiteLocation;
            
            cutSites.push
            (
                {
                    'Candidates' : candidates,
                    'ID': generatedCutsiteId,
                    'Location': locationOnTarget
                }
            );

            FoldCandidates 
            ( 
                { 
                    'ID': generatedCutsiteId,
                    'requestID':request.ID
                }, 
                candidates, 
                reportObj
             ) ; 
		}
		cutsiteTypeCutsiteContainer.Cutsites = cutSites;
		CutsiteTypesCandidateContainer.push(cutsiteTypeCutsiteContainer);
	}
	request.CutsiteTypesCandidateContainer = CutsiteTypesCandidateContainer;
	request.UpdateState("Waiting for foldings ...");
}
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* *****************************************************  Part 2 ***************************************************** */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
function _handleRequestPart2(reportObject) 
{
    var request = reportObject.Request;
    var cutsiteTypes = request.Preferences.cutsites;
    for(var ii = 0; ii < cutsiteTypes.length;++ii)
    {
        var cutsiteTypeContainer = request.CutsiteTypesCandidateContainer[ii].Cutsites;
        for (var jj = 0; jj < cutsiteTypeContainer.length; ++jj)
        {
            var cutsiteContainer = cutsiteTypeContainer[jj];
            var parsedCandidates = ParseUtilities.ParseSFoldResults(request.ID, cutsiteContainer.ID);
            var candidates = cutsiteContainer.Candidates;
            Log("Number of candidates in request: " + candidates.length + ", number of candidates parsed: " + parsedCandidates.length, "HandleRequestPart2 execution", 0);
            if (candidates.length != parsedCandidates.length)
            {
                Log("*** Failed execution! Number of parsed candidates and expected candidates in request:cutsite " + request.ID +':'+ cutsiteContainer.ID + " is different *** ", "ERROR in HandleRequestPart2 execution", 0);
            }
            for (var kk = 0; kk < candidates.length && kk < parsedCandidates.length ; ++kk)
            {
                candidates[kk].StructuresSFold = parsedCandidates[kk];
            }
        }
    }
    reportObject.ExecuteIfComplete(2);
}

function HandleRequestPart2(reportObj)
{
    reportObj.Request.UpdateState('Parsing fold results for candidates...');
    Log("Entered part 2 for " + reportObj.Request.ID, "HandleRequestPart2", 3);
    var reportObject = new ReportObject(reportObj.Request);
    setTimeout(function () { _handleRequestPart2(reportObject); }, 4000); // execute async
}
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* *****************************************************  Part 3 ***************************************************** */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
function _handleRequestPart3(reportObject)
{
    var request = reportObject.Request;
    var seq = request.TargetSequence;
    var constraintsArr = new Array();
    var virtualCandidates = new Array();
    for (var ii = 0; ii < request.CutsiteTypesCandidateContainer.length; ++ii)
    {
        var cutsiteType = request.CutsiteTypesCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteType.Cutsites.length; ++jj)
        {
            var cutsite = cutsiteType.Cutsites[jj];
            virtualCandidates.push
                (
                    {
                        'requestID':request.ID,
                        'cutsiteID': cutsite.ID,
                        'ID':'Target'
                    }
                );
            var constraint = { 'left': cutsite.Location - (request.Preferences.left_arm_max - 1), 'right': (request.Preferences.right_arm_max + request.Preferences.left_arm_max + 2) };
            constraint.left = constraint.left > 0 ? constraint.left : 1;
            constraint.right = ((constraint.right + cutsite.Location - 1) < seq.length) ? constraint.right : (seq.length - cutsite.Location);
            constraintsArr.push(constraint);
        }
    }
    reportObject.FileCount = virtualCandidates.length;
    for (var ii = 0; ii < virtualCandidates.length; ++ii)
    {
        ExecuteFolding(virtualCandidates[ii], constraintsArr[ii], reportObject, true);
    }
}


function HandleRequestPart3(reportObj) {
    var request = reportObj.Request;
    Log("Entered part 3 for " + request.ID, "HandleRequestPart3", 3);
    reportObj.Request.UpdateState('Computing ribozyme shape fitness ... ');
    Log('Computing ribozyme shape fitness ... ', "HandleRequestPart3", 3);
    CaculateCandidateFoldingFitness(request);
    reportObj.Request.UpdateState('Saving request execution ... ');
    SaveRequest(request);
    reportObj.Request.UpdateState('Folding whole sequence ... ');
    var reportObject = new ReportObject(reportObj.Request);
    setTimeout(function () { _handleRequestPart3(reportObject); }, 4000); // execute async
    
}
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* *****************************************************  Part 4 ***************************************************** */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
function _handleRequestPart4(reportObj) {
    var request = reportObj.Request;
    reportObj.FileCount = 0;
    var cutsiteTypes = request.Preferences.cutsites;
    for (var ii = 0; ii < cutsiteTypes.length; ++ii) {
        var cutsiteTypeContainer = request.CutsiteTypesCandidateContainer[ii].Cutsites;
        for (var jj = 0; jj < cutsiteTypeContainer.length; ++jj) {
            //Set execution count for completion of part 4
            reportObj.FileCount += 1; //1 per cutsite in the cutsite type
            //Construct file paths
            var file_pattern_begin = request.ID + '\\' + cutsiteTypeContainer[jj].ID + '\\';
            var file_pattern_end = '\\';//'\\structures\\';
            var file_pattern = file_pattern_begin + 'Target' + file_pattern_end;
            var fileSummary = file_pattern + '10structure_2.out';
            var fileStructures = file_pattern + '10structure.out';
            var index = jj;
            Log("Sending parse request for " + cutsiteTypeContainer[jj].ID + ' target shape with constraints', 'HandleRequestPart4 execution', 1);

            setTimeout
            (
                function (args)
                {
                    
                    var fileSummary = args[1];
                    var fileStructures = args[2];
                    var cutsiteContainer = args[0];
                    var reportObj = args[3];
                    Log("Parsing " + cutsiteContainer.ID + ' target shape with constraints', 'HandleRequestPart4 execution', 1);

                    //Parse structures
                    var Structs = ParseUtilities.ParseStructuresSummary(fileSummary);
                    ParseUtilities.ParseStructure(fileStructures, Structs);

                    Log("Computing " + cutsiteContainer.ID + ' LFE under constraints ', 'HandleRequestPart4 execution', 1);
                    //Find average LFE
                    var lowestFreeEnergy = 0;
                    for (var kk = 0; kk < Structs.length; ++kk) {
                        lowestFreeEnergy += Structs[kk].LowestFreeEnergy * Structs[kk].Frequency;
                    }
                    cutsiteContainer.ConstrainedSFoldStructures = Structs;
                    cutsiteContainer.AverageLowestFreeEnergy = lowestFreeEnergy;
                    reportObj.FileCount -= 1;
                    reportObj.ExecuteIfComplete(4);
                },
                500,
                [cutsiteTypeContainer[jj], fileSummary, fileStructures, reportObj]
            );//Execute Async
        }
    }

}



function HandleRequestPart4(reportObj) {
    var request = reportObj.Request;
    Log("Entered part 4 for " + request.ID, "HandleRequestPart4", 3);
    reportObj.Request.UpdateState('Parsing fold results for target cutsite fitness... ');
    var reportObject = new ReportObject(request);
    setTimeout(function () { _handleRequestPart4(reportObject); }, 4000); // execute async
}


/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* *****************************************************  Part 5 ***************************************************** */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
function _handleRequestPart5(reportObj) {
    var request = reportObj.Request;
    var fs = require('fs');
    var targetSeqFile = request.ID + '/Target.seq';
    fs.writeFileSync(targetSeqFile, '> File for target sequence\n' + request.TargetSequence);
    var resultDir = request.ID + '/Target';
    fs.mkdirSync(resultDir);
    reportObj.FileCount = 1;
    SFold(targetSeqFile, resultDir, reportObj, null, 5);

}



function HandleRequestPart5(reportObj) {
    var request = reportObj.Request;
    Log("Entered part 5 for " + request.ID, "HandleRequestPart5", 3);
    reportObj.Request.UpdateState('Executing Target default folding ');
    var reportObject = new ReportObject(request);
    setTimeout(function () { _handleRequestPart5(reportObject); }, 4000); // execute async
}


/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* *****************************************************  Part 6 ***************************************************** */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
function _handleRequestPart6(reportObj) {
    var request = reportObj.Request;
    var resultDir = request.ID + '/Target';
    var summaryFile = resultDir + '/' + '10structure_2.out';
    var structureFile = resultDir + '/' + '10structure.out';
    //Parse structures
    var Structs = ParseUtilities.ParseStructuresSummary(summaryFile);
    ParseUtilities.ParseStructure(structureFile, Structs);

    Log("Computing " + request.ID + ' LFE without constraints ', 'HandleRequestPart6 execution', 1);
    //Find average LFE
    var lowestFreeEnergy = 0;
    for (var kk = 0; kk < Structs.length; ++kk) {
        lowestFreeEnergy += Structs[kk].LowestFreeEnergy * Structs[kk].Frequency;
    }
    request.SFoldStructures = Structs;
    request.AverageLowestFreeEnergy = lowestFreeEnergy;
    Log("Completed Parsing target fold", 'HandleRequestPart6 execution', 1);
    reportObj.ExecuteIfComplete(6);
}



function HandleRequestPart6(reportObj) {
    var request = reportObj.Request;
    Log("Entered part 6 for " + request.ID, "HandleRequestPart6", 3);
    reportObj.Request.UpdateState('Parsing fold results for target cutsite fitness without constraints... ');
    var reportObject = new ReportObject(request);
    setTimeout(function () { _handleRequestPart6(reportObject); }, 4000); // execute async
}

/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* *****************************************************  Part 7 ***************************************************** */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
/* ******************************************************************************************************************* */
function _handleRequestPart7(reportObj) {
    var request = reportObj.Request;

    reportObj.ExecuteIfComplete(7);
}

function CompressStructureInfo(structureInfo)
{
    var struct = structureInfo;
    var pairs = struct.ConnectedPairs;
    var compressed = new Array();
    for (var mm = 0; mm < pairs.length; ++mm) {
        compressed.push(pairs[mm].left + ',' + pairs[mm].right + ',' + pairs[mm].type);
    }
    struct.ConnectedPairs = compressed;
}

function CompressObjectArrayIntoTable(arrayOfObjects, PropertiesToCompress)
{
    var compressed = new Array();
    //First row is table key (column names)
    var compressedObj = new Array();
    for (var jj = 0; jj < PropertiesToCompress.length; ++jj)
    {
        compressedObj.push(PropertiesToCompress[jj]);
    }
    //Push Key
    compressed.push(compressedObj);


    for (var ii = 0; ii < arrayOfObjects.length; ++ii) {
        var candidate = arrayOfObjects[ii];
        compressedObj = new Array();
        for (var jj = 0; jj < PropertiesToCompress.length; ++jj) {
            compressedObj.push(candidate[PropertiesToCompress[jj]]);
        }
        compressed.push(compressedObj);
    }
    arrayOfObjects.length = 0;
    for (var ii = 0 ; ii < compressed.length; ++ii) {
        arrayOfObjects.push(compressed[ii]);
    }
}

function CompressCandidates(candidates)
{
    for (var ii = 0; ii < candidates.length ; ++ii) {
        var structuresFold = candidates[ii].StructuresSFold;
        CompressObjectArrayIntoTable(structuresFold, ["EnergyInterval", "Frequency", "LowestFreeEnergy", "ConnectedPairs", "Fitness"]);
    }
    CompressObjectArrayIntoTable(candidates, ["Sequence", "CataliticCoreStart", "ID", "StructuresSFold", "StructureUnaFold", "Fitness_Shape", "Fitness_Shape_dG", "Fitness_Target", "Fitness_Target_dG", "Fitness_Specificity", "Fitness_AnnealingT", "CataliticCoreType", "cutSiteID", "cutSiteLocation", "requestID", "MeltingTemperature", "LeftArmLength", "RightArmLength"]);
}

function HandleRequestPart7(reportObj) {
    var request = reportObj.Request;
    Log("Entered part 7 for " + request.ID, "HandleRequestPart7", 3);
    reportObj.Request.UpdateState('Compressing results');



    for (var ii = 0; ii < request.CutsiteTypesCandidateContainer.length; ++ii)
    {
        var cutsiteType = request.CutsiteTypesCandidateContainer[ii];
        for (var jj = 0; jj < cutsiteType.Cutsites.length; ++jj)
        {
            var cutsite = cutsiteType.Cutsites[jj];
            var SFoldStructures = cutsite.ConstrainedSFoldStructures;
            for (var kk = 0; kk< SFoldStructures.length; ++kk)
            {
                var struct = SFoldStructures[kk];
                CompressStructureInfo(struct);
            }

            var candidates = cutsite.Candidates;
            for (var kk = 0; kk < candidates.length; ++kk)
            {
                var structures = candidates[kk].StructuresSFold;
                for (var mm = 0; mm < structures.length; ++mm)
                {
                    CompressStructureInfo(structures[mm]);
                }
                
            }
            CompressCandidates(candidates);
        }
    }

    SaveRequest(request);
    Log("Compressed and saved request " + request.ID, "HandleRequestPart7", 3);

    var reportObject = new ReportObject(request);
   // setTimeout(function () { _handleRequestPart7(reportObject); }, 4000); // execute async
}


exports.HandleRequestPart1 = HandleRequestPart1;
exports.HandleRequestPart2 = HandleRequestPart2;