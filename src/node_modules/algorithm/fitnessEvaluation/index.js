var MeltingTemp = require('../meltingTemp/');


/*
    <summary>
    Given a request object, goes through all candidates, and evaluates the fitness of their structures.
    Finally, it does a weighted average of their structures based on how frequent the structure is likely to 
    occur
    </summary>
    <param name='sequence'>The request structure</param>
    <return>The request structure will be modified, the candidate will have its fitness appropriately changed</return>
*/
function CaculateCandidateFoldingFitness(request) {
    var cutsiteTypesLength = request.CutsiteTypesCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii) {
        var cutsiteTypeCutsiteContainer = request.CutsiteTypesCandidateContainer[ii].Cutsites;
        for (var jj = 0; jj < cutsiteTypeCutsiteContainer.length ; ++jj) {
            var cutsite = cutsiteTypeCutsiteContainer[jj];
            for (var kk = 0; kk < cutsite.Candidates.length ; ++kk) {
                var candidate = cutsite.Candidates[kk];
                var folds = candidate.StructuresSFold;
                var totalFitness = 0;
                for (var ll = 0; ll < folds.length; ++ll) {
                    folds[ll].Evaluate(candidate.CataliticCoreStart, candidate.CataliticCoreType, request.Preferences);
                    totalFitness += folds[ll].Fitness * folds[ll].Frequency;
                }
                candidate.Fitness_Shape = totalFitness;
            }
        }
    }
}

/*
    <summary>
    Given a StructureInfo object and a start and end index, finds all the continious sets of base-pairs,
    that is to say all base-pairs that are joined together
    </summary>
    <param name='structureInfo'>The StructureInfo object</param>
    <param name='start'>The start index to look for continous pairs</param>
    <param name='structureInfo'>The end index</param>
    <return>An array of substrins of the structure that is connnected</return>
*/
function _getContiniousPairsInRegion(structureInfo, start, end) {
    var result = new Array();
    var pairs = structureInfo.ConnectedPairs;
    for (var ii = start; ii < end && ii < pairs.length; ++ii) {
        var continiousSeq = '';
        for (var jj = ii; jj < pairs.length; ++jj) {
            if (pairs[jj].right != -1)
                continiousSeq += pairs[jj].type;
            else if (jj + 1 < pairs.length && pairs[jj + 1].right == -1) //the current and the next are not connected
            {
                if (continiousSeq.length != 0) {
                    result.push(continiousSeq);
                    ii = jj;
                    break;
                }
            }
            else if (jj + 1 < pairs.length && pairs[jj + 1].right != -1) //the current isnt connected, the next one is
            {
                continue;
            }
            else //its the end, and its not connected
            {
                if (continiousSeq.length != 0) {
                    result.push(continiousSeq);
                    ii = jj;
                    break;
                }
            }
        }
    }
    return result;
}

/*
    <summary>
     Given an array of StructureInfo of a target fold, and where the candidate would attatch (attach region),
     the Target fitness  (accesibility) will be computed based on how high the Melting temperature is
     on all continious pairs
    </summary>
    <param name='structureInfoArray'>The request strucure</param>
    <param name='leftArmLength'>The left arm length for the candidate</param>
    <param name='rightArmLength'>The right sarm length for the candidate</param>
    <param name='cutSiteLocation'>Where the candidate will land</param>
    <param name='saltConc'>salt concentration to evaluate melting temperature</param>
    <return>The fitness for the target, for the given region</return>
*/
function EvaluateTargetFoldsFitness(structureInfoArray, leftArmLength, rightArmLength, cutSiteLocation, saltConc) {
    if (saltConc == undefined)
        saltConc = null;
    
    var totalFitness = 0;
    for (var ii = 0 ; ii < structureInfoArray.length; ++ii) {
        var continiousSeqArr = _getContiniousPairsInRegion(structureInfoArray[ii], cutSiteLocation - leftArmLength, cutSiteLocation + rightArmLength);
        var partialFitness = 0;
        //add the melting temperature of continious pairs
        for (var jj = 0; jj < continiousSeqArr.length; ++jj) {
            if (saltConc == null)
                partialFitness += MeltingTemp.MeltingTCalc.tm_Basic(continiousSeqArr[jj]);
            else
                partialFitness += MeltingTemp.MeltingTCalc.tm_Salt_Adjusted(continiousSeqArr[jj], saltConc);
        }
        totalFitness += partialFitness * structureInfoArray[ii].Frequency;

    }
    return totalFitness;
}


/*
    <summary>
     Given a finalized request structure finds the fitnesses of the target, 
     the Free energy and the Melting temperature and adds them to the candidate accordingly
    </summary>
    <param name='sequence'>The request strucure</param>
    <return>The request structure will be modified, the candidate will have its fitness appropriately changed</return>
*/
function EvaluateFitnesses(request) {
    var NormalSFoldShapes = request.SFoldStructures;
    var cutsiteTypesLength = request.CutsiteTypesCandidateContainer.length;
    for (var ii = 0; ii < cutsiteTypesLength; ++ii) {
        var cutsiteTypeCutsiteContainer = request.CutsiteTypesCandidateContainer[ii].Cutsites;
        for (var jj = 0; jj < cutsiteTypeCutsiteContainer.length ; ++jj) {
            var cutsite = cutsiteTypeCutsiteContainer[jj];
            var ConstrainedSFoldStructures = cutsite.ConstrainedSFoldStructures;
            for (var kk = 0; kk < cutsite.Candidates.length ; ++kk) {
                var candidate = cutsite.Candidates[kk];
                //Check the cutsite region for annealing Temperature
                candidate.Fitness_Target = EvaluateTargetFoldsFitness(NormalSFoldShapes, candidate.LeftArmLength, candidate.RightArmLength, candidate.cutSiteLocation, request.Preferences.naEnv);
                //This might be inverted. In the end, the closer it is to zero the better. It will always have one sign or the other.
                //if it has both, it would mean that it is easier to have a completely open cutsite than a normal cutsite.
                candidate.Fitness_Target_dG = request.AverageLowestFreeEnergy - cutsite.AverageLowestFreeEnergy;
                candidate.Fitness_AnnealingT = candidate.MeltingTemperature; //We could normalize. (this would mean adding 276 to transform to kelvin, then divide by the biggest one). I feel this is more descriptive and less convoluted
            }
        }
    }
}


exports.EvaluateFitnesses = EvaluateFitnesses;
exports.CaculateCandidateFoldingFitness = CaculateCandidateFoldingFitness;