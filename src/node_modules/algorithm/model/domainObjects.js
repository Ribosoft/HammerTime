var MeltingTCalc = require('../meltingTemp/').MeltingTCalc.tm_Basic;

var CATALITIC_CORES =
[
	//Normal
	[
		{'left':0,'right':11,'type':'U'},
		{'left':0,'right':11,'type':'C'},
		{'left':0,'right':11,'type':'U'},
		{'left':0,'right':11,'type':'G'},
		{'left':0,'right':11,'type':'A'},
		{'left':0,'right':11,'type':'U'},
		{'left':0,'right':11,'type':'G'},
		{'left':0,'right':11,'type':'A'},
		{'left':0,'right':11,'type':'G'},
		{'left':1,'right':10,'type':'U'},
		{'left':2,'right':9,'type':'C'},
		{'left':3,'right':8,'type':'C'},
		{'left':4,'right':-1,'type':'G'}, //Not connected
		{'left':5,'right':-1,'type':'U'},
		{'left':6,'right':-1,'type':'G'},
		{'left':7,'right':-1,'type':'A'}, //End not connected
		{'left':8,'right':3,'type':'G'},
		{'left':9,'right':2,'type':'G'},
		{'left':10,'right':1,'type':'A'},
		{'left':11,'right':0,'type':'C'}
	]
	//Whishbone
];


function Request ( targetSequence , accessionNumber, preferences , Id )
{
	this.ID = Id;
	this.TargetSequence = targetSequence;
	this.AccessionNumber = accessionNumber == undefined? null : accessionNumber;
	this.Preferences = preferences;
}


function Candidate ( sequence , cataliticCoreStart, Id, coreType, requestID ,cutsiteID, cutSiteLocation)
{
	this.Sequence = sequence;
	this.CataliticCoreStart = cataliticCoreStart;
	this.ID = Id;
	this.StructuresSFold = new Array();
	this.StructureUnaFold = null;
	this.Fitness_Shape = 0;
	this.Fitness_Shape_dG = 0;
	this.Fitness_Target = 0;
	this.Fitness_Target_dG = 0;
	this.Fitness_Specificity = 0;
	this.Fitness_AnnealingT = 0;
	this.CataliticCoreType = coreType;
	this.cutSiteID = cutsiteID;
	this.cutSiteLocation = cutSiteLocation;
	this.requestID = requestID;
}


function StructureInfo (minEnergy,maxEnergy,freq,LowestFreeEnergy)
{
	this.EnergyInterval = {'Min': minEnergy, 'Max' : maxEnergy};
	this.Frequency = freq;
	this.LowestFreeEnergy = LowestFreeEnergy;
	this.ConnectedPairs = new Array();
	this.Fitness = -1;
}

StructureInfo.prototype.toString = function ( )
{
	var pairs = this.ConnectedPairs;
	var res = "Structure " + " freq:" + this.Frequency + ' LFE:' + this.LowestFreeEnergy + ' fitness:' + this.Fitness +'\n';
	for(var ii = 0; ii < ConnectedPairs.length; ++ii)
	{
		res += '\t' + pairs[ii].type + ' pos:' + pairs[ii].left + ' connected to:' + (pairs.right == -1? 'nothing' :  pairs.right);
	}
	return res;
}


StructureInfo.prototype.AddPair = function ( left, right, type)
{
	this.ConnectedPairs.push({'left':left,'right':right,'type':type});
}

StructureInfo.prototype.Evaluate = function (cataliticCoreStartNode, catCoreType)
{
	//Find first pair of catalitic core
	var pairs = this.ConnectedPairs;
	this.Fitness = 0;
	this._evaluateCataliticCore(cataliticCoreStartNode,catCoreType);

	//Exclude catalitic core pairs and non-conecting pairs
	var excludedPairs = this._getPairsNotInCataliticCore(cataliticCoreStartNode,catCoreType);
	
	var MeltOfContiniousPairs = new Array(); //Just for debug of individual melt Ts
	
	for(var ii = 0; ii < excludedPairs.length ; ++ii)
	{
		var ContPair = ""; ContPair += excludedPairs[ii].type;
		var bump = false;
		var jj = ii + 1;
		for(; jj < excludedPairs.length ; ++jj)
		{
			if(excludedPairs[ii].left + 1 == excludedPairs[jj].left ||  excludedPairs[ii].left + 2 == excludedPairs[jj].left)
			{	
				ContPair += excludedPairs[jj].type;
				ii += 1;
			}
			else //Continuity broken
			{
				ii = jj - 1; //Pre-see increment
				break;
			}
		}
		
		var tMelt = MeltingTCalc(ContPair)
		//console.log(ContPair + " m: " + tMelt);
		MeltOfContiniousPairs.push(tMelt);
		this.Fitness += tMelt;
	}
	console.log("Fitness:" + this.Fitness);
	
	
}

//Returns a list with only non-catalitic core pairs that are linked
StructureInfo.prototype._getPairsNotInCataliticCore = function(cataliticCoreStartNode,catCoreType)
{
	var catCoreStruct = CATALITIC_CORES[catCoreType];
	var res  = new Array(); //ExcludedPairs means pairs that are NOT cat Pairs
	var pairs = this.ConnectedPairs;
	var coreIndex = 0;
	for(var ii = 0;ii < pairs.length;++ii)// 
	{
		var isCatCorePair = false
		for(var jj = 0; jj < catCoreStruct.length; ++jj)
		{
			if(pairs[ii].left == catCoreStruct[jj].left + cataliticCoreStartNode && pairs[ii].right == (catCoreStruct[jj].right == -1 ? -1 :(catCoreStruct[jj].right + cataliticCoreStartNode )))
			{
				isCatCorePair = true;
				break;
			}
		}
		// console.log('\tPair ' + pairs[ii].left  + ',' + pairs[ii].right  + ' is ' + isCatCorePair + ' cat core pair');
		var isTruePair = pairs[ii].right != -1;
		if(!isCatCorePair && isTruePair)
			res.push(pairs[ii]);
		
	}
	return res;
}


StructureInfo.prototype._evaluateCataliticCore = function( catCoreStartNode,catCoreType )
{
	//Find first pair of catalitic core
	var locOfCatPair = -1;
	var pairs = this.ConnectedPairs;
	var coreStruct = CATALITIC_CORES[catCoreType];
	for(var ii = 0; ii < pairs.length; ++ii)
	{
		if(pairs[ii].left==catCoreStartNode)
		{locOfCatPair = ii;break;}
	}
	//check if entire core is there
	var pass = true;
	if(locOfCatPair != -1)
	{
		var coreIndex = 0;
		var pairIndex = locOfCatPair;
		while (coreIndex < coreStruct.length && pairIndex < pairs.length)
		{
			if( pairs[pairIndex].right != (coreStruct[coreIndex].right == -1 ? -1 :(catCoreStartNode + coreStruct[coreIndex].right))
			|| pairs[pairIndex].left != catCoreStartNode + coreStruct[coreIndex].left )				
			{
				console.log('The node '+ pairs[pairIndex].left + ' of the catalictic core node ' + coreIndex + ' is not properly connected. ');

				pass = false;
				break;
			}

			coreIndex++;
			pairIndex++;

		}

		
	}
	else
	{
		//The first pair was missing
		pass = false;
		console.log("Cat core G node missing");
	}
	
	if(!pass)
	{
		this.Fitness += 50;
	}
}

function ReportObject()
{
	this.FileCount = 0
}


ReportObject.prototype.ExecuteIfComplete = function ()
{
	console.log('complete');
}

exports.Candidate = Candidate;
exports.StructureInfo = StructureInfo;
exports.CATALITIC_CORES = CATALITIC_CORES;
exports.ReportObject=ReportObject;