var Utils = require('../AlgorithmUtilities.js');
var ReverseComplement = Utils.ReverseComplement;
var DnaToRna = Utils.DnaToRna;
function FindCutsites( seq ,  CutSiteType )
{
	var loc = new Array();
	res = -1;
	do
	{
		res = seq.indexOf(CutSiteType, res + 1);
		if(res !== -1)
			loc.push(res);
	}
	while (res !== -1);
	return loc;
}

function CreateCandidates (seq, cutSites, options)
{
	var Candidates = new Array();
	//Per cutsite
	//Load params
	var lamin = options.left_arm_min;
	var ramin = options.right_arm_min;
	var lamax = options.left_arm_max;
	var ramax = options.right_arm_max;
	
	for(var ii = 0 ; ii < cutSites.length;++ii)
	{
		var firstCutsiteCands = new Array();
		for(var jj = lamin; jj < lamax; ++jj) //jj is the index of G in GUC
		{
			var start = cutSites[ii] - jj;
			if(start < 0)
				continue;
			for(var kk = ramin; kk < ramax; ++kk)
			{
				var end = cutSites[ii]+3+kk;
				var length = end - start;
				if(end >= seq.length)
					continue;
				var candidateSequence = ReverseComplement(seq.substr(start,length));
				var candidateULocation = candidateSequence.length - (jj+2) - 1; //jj +2  is the index of C in GUC, this transforms it into the index of U in the reverse complement
				firstCutsiteCands.push({"seq" : candidateSequence, "cut":candidateULocation, "targetLocation" :cutSites[ii], 'left':jj,'right':kk});
				
			}
		}
		
		Candidates.push(firstCutsiteCands);
	}

	return Candidates;
}

function AppendPromoter(candidates,promoter, depth)
{
	var promAdded =  DnaToRna ( ReverseComplement (promoter) );
	
	for(var cutSiteIndex = 0; cutSiteIndex < candidates.length; ++cutSiteIndex)
	{
		var currentCutsite = candidates[cutSiteIndex];
		for(var candIndex = 0; candIndex < currentCutsite.length ; ++candIndex)
		{
			var candidate = currentCutsite[candIndex].seq;
			var jj;
			for( jj = 0; jj < depth ;++jj)
			{
				var ii;
				var match = true;
				for( ii = 1 ; ii <= depth - jj; ++ii)
				{
					if( candidate[candidate.length - ii] != promAdded[ii-1] )
					{
						match = false;
						break;
					}
				}
				if(match)
				{
					break;
				}
			}
			var matchBegin = depth - jj;
			currentCutsite[candIndex].seq += promAdded.substr(matchBegin);
		}	
	}
}


function GenerateCandidates( sequence, cutSiteType, options )
{
	var csites = FindCutsites (sequence, cutSiteType);
	var candidates = CreateCandidates(sequence, csites, options);
    //TODO: Call append promoter AFTER the candidate cleanse has been executed
	//if(options.promoter != undefined && options.promoter != '')
	//{
	//	AppendPromoter(candidates,options.promoter, 3);
	//}
	return candidates;
}

function AppendPromoterToMany(candidateArray, promoter, promoterCompatRange)
{
    if (promoter != undefined && promoter != '')
    {
        AppendPromoter(candidateArray, promoter, promoterCompatRange);
    }
    return candidateArray;
}

exports.GenerateCandidates = GenerateCandidates;
exports.AppendPromoterToMany = AppendPromoterToMany;