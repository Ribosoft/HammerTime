var Utils = require('../AlgorithmUtilities.js');
var ReverseComplement = Utils.ReverseComplement;
var DnaToRna = Utils.DnaToRna;
function FindCutsites( seq ,  CutSiteType )
{
	var loc = new Array();
	res = -1;
	do
	{
		res = seq.indexOf(CutSiteType, res + 1);
		if(res !== -1)
			loc.push(res);
	}
	while (res !== -1);
	return loc;
}

function CreateCandidates (seq, cutSites, options)
{
	var Candidates = new Array();
	//Per cutsite
	//Load params
	var lamin = options.left_arm_min;
	var ramin = options.right_arm_min;
	var lamax = options.left_arm_max;
	var ramax = options.right_arm_max;
	
	for(var ii = 0 ; ii < cutSites.length;++ii)
	{
		var firstCutsiteCands = new Array();
		for(var jj = lamin; jj < lamax; ++jj)
		{
			var start = cutSites[ii] - jj;
			if(start < 0)
				continue;
			for(var kk = ramin; kk < ramax; ++kk)
			{
				var end = cutSites[ii]+3+kk;
				var length = end - start;
				if(end >= seq.length)
					continue;
				firstCutsiteCands.push({"seq" : seq.substr(start,length), "cut":(jj+2), "targetLocation" :cutSites[ii]});
				
			}
		}
		Candidates.push(firstCutsiteCands);
	}

	return Candidates;
}

function AppendPromoter(candidates,promoter, depth)
{
	var promAdded =  DnaToRna ( ReverseComplement (promoter) );
	
	for(var cutSiteIndex = 0; cutSiteIndex < candidates.length; ++cutSiteIndex)
	{
		var currentCutsite = candidates[cutSiteIndex];
		for(var candIndex = 0; candIndex < currentCutsite.length ; ++candIndex)
		{
			var candidate = currentCutsite[candIndex].seq;
			var jj;
			for( jj = 0; jj < depth ;++jj)
			{
				var ii;
				var match = true;
				for( ii = 1 ; ii <= depth - jj; ++ii)
				{
					if( candidate[candidate.length - ii] != promAdded[ii-1] )
					{
						match = false;
						break;
					}
				}
				if(match)
				{
					break;
				}
			}
			var matchBegin = depth - jj;
			currentCutsite[candIndex].seq += promAdded.substr(matchBegin);
		}	
	}
}


function GenerateCandidates( sequence, cutSiteType, options )
{
	var csites = FindCutsites (sequence, cutSiteType);
	var candidates = CreateCandidates(sequence, csites, options);
	if(options.promoter != undefined && options.promoter != '')
	{
		AppendPromoter(candidates,options.promoter, 3);
	}
	return candidates;
}


exports.GenerateCandidates = GenerateCandidates;