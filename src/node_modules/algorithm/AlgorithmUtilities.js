
String.prototype.replaceAll = function(find,replace)
{
	return this.replace(new RegExp(find, 'g'), replace);
}

function Complement( oligo , isRna )
{
	if(isRna == undefined)
		isRna = true;
	var res = new Array();
	for(var ii = 0; ii < oligo.length; ++ii)
	{
		var c = oligo[ii];
		switch(c)
		{
			case 'G':
				res.push('C');
				break;
			case 'C':
				res.push('G');
				break;
			case 'A':
				if(isRna)
					res.push('U');
				else
					res.push('T');
				break;
			case 'U':
			case 'T':
				res.push('A');
					break;
			default:
				res.push(c);
		}
	}
	return res.join('');
}

function Reverse( oligo )
{
	return oligo.split("").reverse().join("");
}

function ReverseComplement(oligo)
{
	return Complement(Reverse(oligo));
}

function SequenceLength (oligo)
{
	var res = 0;
	for(var ii = 0; ii < oligo.length; ++ii)
	{
		var c = oligo[ii];
		switch(c)
		{
			case 'G':
				res +=1;
				break;
			case 'C':
				res +=1;
				break;
			case 'A':
				res +=1;
				break;
			case 'U':
			case 'T':
				res +=1;
				break;

		}
	}
	return res;
}

function RnaToDna(seq)
{
	return seq.replaceAll('U','T');
}
function DnaToRna(seq)
{
	return seq.replaceAll('T','U');
}


function CompressStructureInfo(structureInfo) {
    var struct = structureInfo;
    var pairs = struct.ConnectedPairs;
    var compressed = new Array();
    for (var mm = 0; mm < pairs.length; ++mm) {
        compressed.push(pairs[mm].left + ',' + pairs[mm].right + ',' + pairs[mm].type);
    }
    struct.ConnectedPairs = compressed;
}

function CompressObjectArrayIntoTable(arrayOfObjects, PropertiesToCompress) {
    var compressed = new Array();
    //First row is table key (column names)
    var compressedObj = new Array();
    for (var jj = 0; jj < PropertiesToCompress.length; ++jj) {
        compressedObj.push(PropertiesToCompress[jj]);
    }
    //Push Key
    compressed.push(compressedObj);


    for (var ii = 0; ii < arrayOfObjects.length; ++ii) {
        var candidate = arrayOfObjects[ii];
        compressedObj = new Array();
        for (var jj = 0; jj < PropertiesToCompress.length; ++jj) {
            compressedObj.push(candidate[PropertiesToCompress[jj]]);
        }
        compressed.push(compressedObj);
    }
    arrayOfObjects.length = 0;
    for (var ii = 0 ; ii < compressed.length; ++ii) {
        arrayOfObjects.push(compressed[ii]);
    }
}

function CompressCandidates(candidates) {
    for (var ii = 0; ii < candidates.length ; ++ii) {
        var structuresFold = candidates[ii].StructuresSFold;
        CompressObjectArrayIntoTable(structuresFold, ["EnergyInterval", "Frequency", "LowestFreeEnergy", "ConnectedPairs", "Fitness"]);
    }
    CompressObjectArrayIntoTable(candidates, ["Sequence", "CataliticCoreStart", "ID", "StructuresSFold", "StructureUnaFold", "Fitness_Shape", "Fitness_Shape_dG", "Fitness_Target", "Fitness_Target_dG", "Fitness_Specificity", "Fitness_AnnealingT", "CataliticCoreType", "cutSiteID", "cutSiteLocation", "requestID", "MeltingTemperature", "LeftArmLength", "RightArmLength"]);
}



exports.SequenceLength = SequenceLength;
exports.ReverseComplement = ReverseComplement;
exports.Reverse = Reverse;
exports.Complement =  Complement;
exports.DnaToRna = DnaToRna;
exports.RnaToDna = RnaToDna;

exports.CompressStructureInfo = CompressStructureInfo;
exports.CompressObjectArrayIntoTable = CompressObjectArrayIntoTable;
exports.CompressCandidates = CompressCandidates;